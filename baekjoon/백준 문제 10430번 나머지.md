package com.project.codingtest;  
  
import java.util.Scanner;  
  
public class Main {  
    public static void main(String[] args) {  
        Scanner sc  = new Scanner(System.in);  
        int A = sc.nextInt();  
        int B = sc.nextInt();  
        int C = sc.nextInt();  
  
        System.out.println((A+B)%C);  
        System.out.println(((A%C)+(B%C))%C);  
        System.out.println((A*B)%C);  
        System.out.println(((A%C)*(B%C))%C);  
  
    }  
}

package com.project.codingtest;  
  
import java.util.Scanner;  
  
public class Main {  
    public static void main(String[] args) {  
        try (Scanner sc = new Scanner(System.in)) {  
            int A = sc.nextInt();  
            int B = sc.nextInt();  
            int C = sc.nextInt();  
  
           int[] results = computedModIdentities(A, B, C);  
           StringBuilder sb = new StringBuilder();  
           for (int r: results) sb.append(r).append('\n');  
           System.out.print(sb);  
        }  
    }  
  
    static int[] computedModIdentities(int A, int B, int C){  
        int aMod = A % C;  
        int bMod = B % C;  
  
        int r1 = (A + B) % C;  
        int r2 = (aMod + bMod) % C;  
        int r3 = (A * B) % C;  
        int r4 = (aMod * bMod) % C;  
  
        return new int[] {r1, r2, r3, r4};  
    }  
}

AI 핵심 개선 포인트

- I/O와 로직 분리
  변환/계산 로직을 메서드로 분리하여 테스트 하기 쉽게 만든다

- 중복 제거
  여러 번 쓰이는 A % C, B% C는 캐싱한다.

- `System.out.println()`을 반복 호출하는 경우의 단점
  출력할 때마다 표준 출력 버퍼 -> 콘솔로 데이터가 전송됨.

  I/O연산은 CPU 연산보다 훨씬 느려서, 데이터가 많아질수록 성능
  차이가 커짐.

- `StringBuilder`를 쓰는 장점
  반복문에서 문자열을 하나의 버퍼에 메모리상에서만 합침.

  마지막에 단 한 번만 출력 -> I/O 호출 횟수 최소화.