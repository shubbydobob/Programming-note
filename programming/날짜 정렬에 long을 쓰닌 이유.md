날짜 정렬을 빠르고 정확하게 하기 위해서 Date 객체가 아닌 long을 쓴다.

1. 날짜를 문자열로 비교하면 문제가 생김
예를 들어, 문자열 "2025-08-02"와 "2025-07-30"을 비교하면
문자열 비교(lexicographical)에서는 "2025-08-02"가 "2025-07-30"보다 큽니다.
yyyy-MM-dd 형식은 문자열 비교로도 날짜 순서가 맞긴 하지만,
시분초까지 들어가거나 포맷이 바뀌면 정렬이 틀어질 수 있어요.

2. Date 객체보다 long이 빠름
Date를 직접 비교할 수도 있지만,
Date는 객체 비교라서 오토박싱/언박싱 비용이 들어갑니다.
getTime()으로 long 값(UTC 기준 epoch milliseconds)을 뽑으면
그냥 숫자 비교라서 더 단순하고 빠르죠.

3. Comparator에서 간단하게 정렬 가능
rows.sort(Comparator.comparingLong(m -> (Long) m.get("_startEpoch")));

이렇게 하면 바로 오름차순으로 정렬되고,
내림차순도 .reversed() 붙이면 됩니다.

즉, _startEpoch = "해당 운행의 시작 시각을 밀리초 단위로 변환한 값"

장점: 정렬 안정성, 성능, 타입 안정성

단점: 화면에 바로 쓰려면 다시 포맷팅 필요